/*******************************************************************************
** Module Name:
**    HtiGenBinary.c
**
** Purpose:
**    Generates a binary file for the HTI library.
**
** Description:
**    This module contains the code for converting from the text based code
**    generated by the main HTI conversion utilities into a binary file
**    suitable for rapid lookup.
**
**    To distinguish this code from other aspects of the HTI library, the
**    acronym GBF (Generate Binary File) is appeanded to HTI, whenever that
**    acronym is used (e.g. in function names).
**
** Traceability to Software Design:
**    \\Files\97-001\Development-New\2000 TSD Telescope Software Development\
**    MCS Master Control System\User Manuals\Hti & Tst\HTI & TST User Guide
**    v0.04.doc
**
** Author(s):
**    Derek J. McKay (djm)
**    Andrzej S. Piascik (asp)
**
** Copyright (c) Telescope Technologies Limited (TTL), 2000-2002
**
** Version:
**    $Id: HtiGenBinary.c,v 0.8 2007/03/12 15:22:59 sxf Exp $
**
** History:
**    $Log: HtiGenBinary.c,v $
**    Revision 0.8  2007/03/12 15:22:59  sxf
**    Minor modification to build under linux.
**
**    Revision 0.7  2005/06/20 13:29:34  mjf
**    Tidied to aid porting to Linux - no functional changes.
**
**    Revision 0.6  2002/10/18 09:03:59  dws
**    fixed comments
**
**    Revision 0.4  2002/09/12 15:26:51  djm
**    Minor corrections to comments.
**
**    Revision 0.3  2002/04/22 12:53:43  djm
**    Fixed incorrectly specified string length symbolic constants.
**
**    Revision 0.2  2002/04/18 15:22:45  djm
**    Major work to get this utility operational.
**
**    Revision 0.1  2002/04/04 14:59:12  djm
**    Initial creation.
**
**
*******************************************************************************/

/*
** Compiler include files
*/
#include <string.h>


/*
** System include files
*/

#include "TtlSystem.h"
#include "Hti.h"
#include "HtiPrivate.h"
#include "Cil.h"


/*
** Symbolic constants
*/



/*
** Global variables
*/

FILE *mHtiGbfInFilePtr;    /* Pointer for the input file */
FILE *mHtiGbfOutFilePtr;   /* Pointer for the output file */
char **mHtiGbfRecArrayPtr; /* Pointer to an array of record pointers */
size_t mHtiGbfNumRecs;     /* Number of records in record array */

Bool_t mHtiGbfConvertCil = TRUE;   /* shows wether or not to convert the first 
                                      column in the file using the cil name 
                                      lookup functions */
/*
** Module function prototypes
*/


Status_t mHtiGbfFileStats
(
   size_t *NumRecs,
   size_t *RecSize
);

Status_t mHtiGbfLoadRecs
(
   size_t  MaxRecs,
   size_t  RecSize
);

void mHtiGbfExit
(
   char *ProgNamePtr,
   char *ErrorStrPtr
);

Status_t mHtiGbfSortRecs(void);

int mHtiGbfCompareRecs
(
   const void *APtr,
   const void *BPtr
);

Status_t mHtiGbfPrintRecs
(
   size_t RecSize
);

Status_t mHtiGbfSaveBinFile
(
   size_t RecSize
);


/*
** Module functions
*/

/*******************************************************************************
** Function Name:
**    main
**
** Purpose:
**    Main entry point function for the HtiGenBinary program.
**
** Description:
**    This is the top level function of this utility program. It calls
**    functions to perform the following acticities:
**
**       read in records from the ASCII "index" file
**       sort these records into a suitable order
**       write the records in binary format to file
**
**    If the program fails in any way, then an error message will be
**    written to standard output, and the program will terminate.
**
** Return Type:
**    int
**       Returns the completion status of the program (either
**       EXIT_SUCCESS or EXIT_FAILURE).
**
** Arguments:
**    int Argc                 (in)
**       Number of arguments on the command line (including the
**       executable name).
**    char *Argv[]             (in)
**       Array of (Argc) NUL-terminated character strings containing
**       the command line arguments.
**
** Author(s):
**    Derek J. McKay (djm)
**    Andrzej S. Piascik (asp)
**
*******************************************************************************/

int main
(
   int Argc,
   char* Argv[]
)
{
   /* Local variables */
   Status_t Status;    /* Return status of functions */
   size_t NumRecs;     /* Number of records in the file */
   size_t RecSize;     /* Number of bytes needed for a single record */
   Int16_t Counter;     /* Loop Counter */

   /* Initialise any global variables */
   mHtiGbfInFilePtr = NULL;
   mHtiGbfOutFilePtr = NULL;
   mHtiGbfRecArrayPtr = NULL;
   mHtiGbfNumRecs = 0;


   /* Diagnostic message */
   printf("\nHtiGenBinary\n\n");

   /* Parse command line arguments */
   if(Argc >= 2)
   {
      if(strcmp(Argv[1], "-h") == 0)
      {
         mHtiGbfExit(Argv[0], NULL);
      }
   }

   if(Argc >= 4)
   {
     /*
     ** if Cil id is to be converted using Cilname lookup function.
     ** If it isnt the the  Numerical value is simply inserted into
     ** the file.
     */
     for(Counter=0;Counter<Argc;Counter++)
     {
        if(strcmp(Argv[Counter],I_HTI_GENBIN_PACKAGE_SWITCH) == 0)
        {
            printf("Not converting Cil id\n");
            mHtiGbfConvertCil = FALSE; 
       }
     }
   }

   if(Argc < 3)
   {
      mHtiGbfExit(Argv[0], "Not enough arguments");
   }

   /* Open the input file */
   mHtiGbfInFilePtr = fopen(Argv[1], "r");
   if(mHtiGbfInFilePtr == NULL)
   {
      mHtiGbfExit(Argv[0], "Could not open input file");
   }

   /* Open the output file */
   mHtiGbfOutFilePtr = fopen(Argv[2], "wb");
   if(mHtiGbfOutFilePtr == NULL)
   {
      mHtiGbfExit(Argv[0], "Could not open output file");
   }

   /*
   ** Count the number of lines in the index file  and ascertain
   ** the record length of the entries in the index file
   */
   Status = mHtiGbfFileStats(&NumRecs, &RecSize);
   if(Status != SYS_NOMINAL)
   {
      mHtiGbfExit(NULL, "Error getting record details");
   }

   printf("Number of records read from file = %d\n", NumRecs);
   printf("Required size to handle the largest records = %d bytes\n", RecSize);

   /* test to see if works */
   mHtiGbfPrintRecs( RecSize);

   /* Create an array to hold all the entries */
   mHtiGbfRecArrayPtr = TTL_CALLOC(NumRecs, sizeof(char *));
   if(mHtiGbfRecArrayPtr == NULL)
   {
      mHtiGbfExit(NULL, "Unable to allocate memory for storage");
   }
   mHtiGbfNumRecs = NumRecs;

   /* Re-read the file, loading all the data into the array */
   Status = mHtiGbfLoadRecs(NumRecs, RecSize);
   if(Status != SYS_NOMINAL)
   {
      mHtiGbfExit(NULL, "Error getting record details");
   }

   /* Sort the array into CIL-DatumId order */
   Status = mHtiGbfSortRecs();
   if(Status != SYS_NOMINAL)
   {
      mHtiGbfExit(NULL, "Error sorting records");
   }

   /* Print the list of sorted records */
/*
   Status = mHtiGbfPrintRecs(RecSize);
*/

   /* Now we write the output file */
   Status = mHtiGbfSaveBinFile(RecSize);
   if(Status != SYS_NOMINAL)
   {
      mHtiGbfExit(NULL, "Error writing binary output file");
   }

   /* Terminate the program */
   printf("Complete\n");
   mHtiGbfExit(NULL, NULL);
   return EXIT_SUCCESS;

}  /* End of main() */


/*******************************************************************************
** Function Name:
**    mHtiGbfSaveBinFile
**
** Purpose:
**    This function saves the array of records to a binary file.
**
** Description:
**    This function actually writes the records to the output file.
**    The format of the file is as follows:
**
**                            +---+---+---+---+
**       Byte offset = 0      |No. Records = N|
**                            +---+---+---+---+
**
**                            +---+---+---+---+
**       Byte offset = 4      |Record size = M|
**                            +---+---+---+---+
**
**                            +---+---+- - -    - - --+---+
**       Byte offset = 8      | Record 1.                 |
**                            +---+---+- - -    - - --+---+
**
**                            +---+---+- - -    - - --+---+
**       Byte offset = 8+M    | Record 2.                 |
**                            +---+---+- - -    - - --+---+
**
**              :                     :
**              :                     :
**              :                     :
**
**                            +---+---+- - -    - - --+---+
**       Offset = 8+M*(N-1)   | Record N.                 |
**                            +---+---+- - -    - - --+---+
**
** Return Type:
**    Status_t
**       This is SYS_NOMINAL on successful completion of the function,
**       otherwise and error code is returned.
**
** Arguments:
**    size_t RecSize         (in)
**       The size of an individual ID record
**
** Author(s):
**    Derek J. McKay (djm)
**
*******************************************************************************/

Status_t mHtiGbfSaveBinFile
(
   size_t RecSize
)
{
   /* Local variables */
   size_t NumWritten;        /* No.elements written - returned by fwrite() */
   size_t NumRec;            /* Counter for records */
   char *RecPtr;             /* Pointer to a working record */


   /* Diagnostic message */
   printf("Writing records to binary output file\n");

   /* Write the number of records */
   NumWritten = fwrite(&mHtiGbfNumRecs, sizeof(Int32_t), 1, mHtiGbfOutFilePtr);
   if(NumWritten != 1) return SYS_WARNING;


   /* Write the size of an individual record */
   NumWritten = fwrite(&RecSize, sizeof(Int32_t), 1, mHtiGbfOutFilePtr);
   if(NumWritten != 1) return SYS_WARNING;


   /* Write the actual records */

   /* Loop over each record in the array */
   for(NumRec = 0; NumRec < mHtiGbfNumRecs; NumRec++)
   {
      /* Make a local copy of the pointer for convenience */
      RecPtr = *(mHtiGbfRecArrayPtr+NumRec);

      NumWritten = fwrite(RecPtr, RecSize, 1, mHtiGbfOutFilePtr);
      if(NumWritten != 1) return SYS_WARNING;
   }


   /* Terminate the function, returning success */
   return SYS_NOMINAL;

}  /* End of mHtiGbfSaveBinFile() */


/*******************************************************************************
** Function Name:
**    mHtiGbfCompareRecs
**
** Purpose:
**    Compares two records.
**
** Description:
**    This function is used by the qsort() function to decide which of the
**    two records is greater. These records are specified by simply giving
**    the addresses of the variables that hold the addresses of the records
**    themselves. Thus, there is some abstraction which needs to be managed
**    first. For convenience, the data is transferred to local variables.
**    This makes the comparison "if" statements simpler.
**
** Return Type:
**    Status_t
**       This is SYS_NOMINAL on successful completion of the function,
**       otherwise and error code is returned.
**
** Arguments:
**    const void *Arg1Ptr    (in)
**       A pointer to the variable holding the memory address of the first
**       item to be compared. The comparison function is aware of the data
**       structure located at this address.
**    const void *Arg2Ptr    (in)
**       A pointer to the variable holding the memory address of the second
**       item to be compared. The comparison function is aware of the data
**       structure located at this address.
**
** Author(s):
**    Derek J. McKay (djm)
**
*******************************************************************************/

int mHtiGbfCompareRecs
(
   const void *Arg1Ptr,
   const void *Arg2Ptr
)
{
   /* Local variables */
   const char **In1Ptr = (const char **)Arg1Ptr;   /* Local pointer */
   const char **In2Ptr = (const char **)Arg2Ptr;   /* Local pointer */
   Int32_t CilId1;           /* CIL address from the first record */
   Int32_t CilId2;           /* CIL address from the second record */
   Int32_t DatumId1;         /* Datum ID from the first record */
   Int32_t DatumId2;         /* Datum ID from the second record */


   /* Extract the relevant data */
   memcpy((void *)&CilId1, *In1Ptr, sizeof(CilId1));
   memcpy((void *)&CilId2, *In2Ptr, sizeof(CilId2));
   memcpy((void *)&DatumId1, (*In1Ptr)+sizeof(CilId1), sizeof(DatumId2));
   memcpy((void *)&DatumId2, (*In2Ptr)+sizeof(CilId2), sizeof(DatumId2));

   /* Do the actual comparison */
   if(CilId1 > CilId2)
   {
      return 1;
   }
   else if (CilId1 < CilId2)
   {
      return -1;
   }
   else
   {
      if(DatumId1 > DatumId2)
      {
         return 1;
      }
      else if(DatumId1 < DatumId2)
      {
         return -1;
      }
   }

   /* If we get this far, it meant that both entries were the same */
   return 0;

}  /* End of mHtiGbfCompareRecs() */



/*******************************************************************************
** Function Name:
**    mHtiGbfSortRecs
**
** Purpose:
**    To sort the array of records into CIL-DatumID order.
**
** Description:
**    This function sorts the array "mHtiGbfRecArrayPtr" into order according
**    to, firstly, the CIL ID, and then, secondly, the DatumID. It uses the
**    standard "qsort" system function to do the actual sorting. A separate
**    comparison function is provided.
**
**    The function is simply a wrapper about "qsort". It has only been put in
**    place in case additional functionality needs to be added in the future.
**
** Return Type:
**    Status_t
**       This is SYS_NOMINAL on successful completion of the function,
**       otherwise and error code is returned.
**
** Arguments:
**    (none)
**
** Author(s):
**    Derek J. McKay (djm)
**
*******************************************************************************/

Status_t mHtiGbfSortRecs(void)
{

   /* Diagnostic message */
   printf("Sorting records\n");

   /* Sort the records */
   qsort(mHtiGbfRecArrayPtr, mHtiGbfNumRecs, sizeof(char *), mHtiGbfCompareRecs);

   /* Terminate the function and return success */
   return SYS_NOMINAL;

}  /* End of mHtiGbfSortRecs() */


/*******************************************************************************
** Function Name:
**    mHtiGbfPrintRecs
**
** Purpose:
**    To print to standard output the contents of the record array.
**
** Description:
**    This function is primarily for diagnostic purposes. It will probably
**    not be used in the production code, due to the large number of records
**    to be processed.
**
** Return Type:
**    Status_t
**       This is SYS_NOMINAL on successful completion of the function,
**       otherwise and error code is returned.
**
** Arguments:
**    size_t RecSize         (in)
**       The size of an individual ID record
**
** Author(s):
**    Derek J. McKay (djm)
**
*******************************************************************************/

Status_t mHtiGbfPrintRecs
(
   size_t RecSize
)
{
   /* Local variables */
   size_t NumRec = 0;        /* Counter for records */
   int c;                    /* Loop counter for diagnositics */
   char *RecPtr;             /* Pointer to a working record */


   /* Print a heading line */
   printf("_ADDR___RECORD___ _ _ _ \n");

   /* Loop over each record in the array */
   for(NumRec = 0; NumRec < mHtiGbfNumRecs; NumRec++)
   {
      /* Make a local copy of the pointer for convenience */
      RecPtr = *(mHtiGbfRecArrayPtr+NumRec);

      /* Print the memory address of the data */
      printf("%x : ", (unsigned long)RecPtr);

      /* Print the contents of the record */
      for(c = 0; c < RecSize; c++)
      {
         if((*(RecPtr+c) == 0) && c > 7)
         {
            printf(".");
         }
         else if((isprint(*(RecPtr+c))) && c > 7)
         {
            printf("%c", *(RecPtr+c));
         }
         else
         {
            printf("%2.2x ", *(RecPtr+c));
         }
      }

      /* Put on a terminating new-line character */
      printf("\n");
   }


   /* Terminate the function and return success */
   return SYS_NOMINAL;

}  /* End of mHtiGbfPrintRecs() */



/*******************************************************************************
** Function Name:
**    mHtiGbfLoadRecs
**
** Purpose:
**    Load records from the input file into dynamically allocated memory.
**
** Description:
**    This function scans through the open input file and dynamically
**    builds an array of records as read from this file.
**
**    The function assumes that the file pointer is pointing to the start
**    of the file. It rewinds the file pointer to the start of the file
**    before returning.
**
** Return Type:
**    Status_t
**       This is SYS_NOMINAL on successful completion of the function,
**       otherwise and error code is returned.
**
** Arguments:
**    size_t MaxRecs         (in)
**       The number of records that is expected in the file.
**    size_t RecSize         (in)
**       The size of an individual ID record.
**
** Author(s):
**    Derek J. McKay (djm)
**
*******************************************************************************/

Status_t mHtiGbfLoadRecs
(
   size_t  MaxRecs,
   size_t  RecSize
)
{
   /* Local variables */
   char Line[E_HTI_MAX_STRING_LEN];       /* Buffer to hold read-in records */
   char CilStr[E_HTI_MAX_STRING_LEN];     /* String with the record "CilID" */
   char ValueStr[E_HTI_MAX_STRING_LEN];   /* String with the record "value" */
   char LabelStr[E_HTI_MAX_STRING_LEN];   /* String with the record "label" */
   char DescrStr[E_HTI_MAX_STRING_LEN];   /* String with the record "descr" */
   size_t NumRecs = 0;                    /* Counter for records */
   char *RecPtr;                          /* Pointer to a working record */
   Int32_t Value;                         /* Numerical ID value */
   size_t NumValues;                      /* No.Values read from sscanf() */
   Int32_t Id;                            /* Numeric value of CIL ID */


   /* Diagnostic message */
   printf("Reading records from input file\n");

   /* Loop through all the lines in the file */
   while( fgets( Line, sizeof(Line), mHtiGbfInFilePtr) != NULL )
   {
      /* Increment the record counter and check we have room for another one */
      NumRecs++;
      if(NumRecs > MaxRecs) mHtiGbfExit(NULL, "Too many records");

      /* Extract the parameters */
      NumValues = sscanf(Line, I_HTI_DESCR_STR,
                     CilStr, ValueStr, LabelStr, DescrStr);

      /* Check that we have a reasonable number of parameters */
      if( (NumValues < I_HTI_ENTRY_PARAMS) || (NumValues > I_HTI_DESCR_PARAMS) )
      {
         fprintf(stderr, "Only %d values read from record %d (\"%s\")\n",
            NumValues, NumRecs, Line);
         mHtiGbfExit(NULL, "Error reading a record entry for the array");
      } 

      /* Allocate some memory for the record */
      RecPtr = TTL_MALLOC(RecSize);
      if(RecPtr == NULL)
      {
         mHtiGbfExit(
            NULL, "Could not allocate memory for an individual record");
      }
      memset(RecPtr, 0, RecSize);

      /* Write the address of our new record into the record array */
      *(mHtiGbfRecArrayPtr+NumRecs-1) = RecPtr;
  
      /* 
      ** Check if the Cil Id should be converted or not if not then simply place
      ** the read value into Id and dont convert to a cilname.
      */
      if( mHtiGbfConvertCil == TRUE)
      {
         /* Write in the CIL parameter */
         for(Id = E_CIL_BOL; Id < E_CIL_EOL; Id++)
         {
            if( strcmp(CilStr, eCilNameString( Id) ) == 0 ) break;
         }
         memcpy((void *)RecPtr, (void *)&Id, sizeof(Id));
         RecPtr += sizeof(Id);
      }
      else if(mHtiGbfConvertCil == FALSE )
      {
         /* Write in the cil Id */
         Id=strtol(CilStr, NULL, 0);
         memcpy((void *)RecPtr, (void *)&Id, sizeof(Id));
         RecPtr += sizeof(Id);
      }

      /* Write in the value parameter */
      Value = strtol(ValueStr, NULL, 0);
      memcpy((void *)RecPtr, (void *)&Value, sizeof(Value));
      RecPtr += sizeof(Value);

      /* Write in the CIL string */
      memcpy((void *)RecPtr, (void *)CilStr, strlen(CilStr));
      RecPtr += strlen(CilStr) + 1;

      /* Write in the Label string */
      memcpy((void *)RecPtr, (void *)LabelStr, strlen(LabelStr));
      RecPtr += strlen(LabelStr) + 1;

      /* Write in the description string */
      memcpy((void *)RecPtr, (void *)DescrStr, strlen(DescrStr));
      RecPtr += strlen(DescrStr) + 1;

   }  /* End of while-loop */

   /* Rewind the file */
   rewind(mHtiGbfInFilePtr);

   /* Terminate function. If we managed to get this far, it must be a success */
   return SYS_NOMINAL;

}  /* End of mHtiGbfLoadRecs() */



/*******************************************************************************
** Function Name:
**    mHtiGbfFileStats
**
** Purpose:
**    Determine the file record characteristics
**
** Description:
**    This function determines the number of records and the ammount of space
**    required to store them in a fixed-record length format.
**
**    The function assumes that the file pointer is pointing to the start
**    of the file. It rewinds the file pointer to the start of the file
**    before returning.
**
** Return Type:
**    Status_t
**       This is SYS_NOMINAL on successful completion of the function,
**       otherwise and error code is returned.
**
** Arguments:
**    size_t *NumRecs         (out)
**       The number of records that is contained in the file.
**    size_t *RecSize         (out)
**       The size of an individual ID record.
**
** Author(s):
**    Derek J. McKay (djm)
**
*******************************************************************************/

Status_t mHtiGbfFileStats
(
   size_t *NumRecs,
   size_t *RecSize
)
{
   /* Local variables */
   char Line[E_HTI_MAX_STRING_LEN];     /* Buffer to hold read-in records */
   char CilStr[E_HTI_MAX_STRING_LEN];   /* String with the record "CilID" */
   char ValueStr[E_HTI_MAX_STRING_LEN]; /* String with the record "value" */
   char LabelStr[E_HTI_MAX_STRING_LEN]; /* String with the record "label" */
   char DescrStr[E_HTI_MAX_STRING_LEN]; /* String with the record "descr" */
   size_t LineLen;
   size_t MaxComponentLen = 0;          /* Length of longest individual item */


   /* Reset the output variables for the function */
   *NumRecs = 0;
   *RecSize = 0;

   /* Diagnostic message */
   printf("Analysing input file\n");

   /* Loop through all the lines in the file */
   while( fgets( Line, sizeof(Line), mHtiGbfInFilePtr) != NULL )
   {
      Line[sizeof(Line) - 1] = '\0';

      /* Extract the parameters of variable length */
      sscanf(Line, I_HTI_DESCR_STR, CilStr, ValueStr, LabelStr, DescrStr);

      if(strlen(LabelStr) > MaxComponentLen) MaxComponentLen = strlen(LabelStr);
      if(strlen(DescrStr) > MaxComponentLen) MaxComponentLen = strlen(DescrStr);

      /* Determine the line length + 3 * NULs + 8 for the CIL & Datum IDs */
      LineLen = sizeof(Int32_t)
              + sizeof(Int32_t)
              + strlen(CilStr) + 1
              + strlen(LabelStr) + 1
              + strlen(DescrStr) + 1;

      /* Increase the RecSize if the modified LineLen exceeds it */
      if(LineLen > *RecSize) *RecSize = LineLen;

      /* Increment the count of the number of lines */
      (*NumRecs)++;

   }  /* End of while-loop */

   printf("Maximum component string length = %d\n", MaxComponentLen);

   /* Rewind the file */
   rewind(mHtiGbfInFilePtr);

   /* Terminate function. If we managed to get this far, it must be a success */
   return SYS_NOMINAL;

}  /* End of mHtiGbfFileStats() */



/*******************************************************************************
** Function Name:
**    mHtiGbfExit
**
** Purpose:
**    Terminates the program.
**
** Description:
**    This function will print the expected use of the function in terms
**    of specified command line arguments. If the ErrorStrPtr argument is
**    set to NULL, the no error string is printed, otherwise the pointer
**    is used to construct and error message for display. It will terminate
**    the program on completion.
**
** Return Type:
**    void
**
** Arguments:
**    char *ProgNamePtr      (in)
**       Pointer to a string containing the name of the program. If it is
**       set to NULL, then no "program usage" will be printed.
**    char *ErrorStrPtr      (in)
**       Pointer to a string containing any error message to print to the
**       console. If it is set to NULL, then none will be printed.
**
** Author(s):
**    Derek J. McKay (djm)
**
*******************************************************************************/

void mHtiGbfExit
(
   char *ProgNamePtr,
   char *ErrorStrPtr
)
{
   /* Local variables */
   size_t NumRec;            /* Loop counter for clearing the record array */


   /* If an error message is given, then print it */
   if(ErrorStrPtr != NULL)
   {
      fprintf(stderr, "Error: %s\n", ErrorStrPtr);
   }

   /* If the program name is supplied, then print the usage of the program */
   if(ProgNamePtr != NULL)
   {
      fprintf(stderr, "Usage: %s <inputfile> <outputfile>\n", ProgNamePtr);
   }

   /* Clean up any global resources */
   if(mHtiGbfInFilePtr != NULL) fclose(mHtiGbfInFilePtr);
   if(mHtiGbfOutFilePtr != NULL) fclose(mHtiGbfOutFilePtr);

   /* Clean up the array of data */
   for(NumRec = 0; NumRec < mHtiGbfNumRecs; NumRec++)
   {
      TTL_FREE(*(mHtiGbfRecArrayPtr+NumRec));
   }
   TTL_FREE(mHtiGbfRecArrayPtr);

   /* If there have been no problems, then terminate with success status */
   if(ErrorStrPtr == NULL)
   {
      exit(EXIT_SUCCESS);
   }

   /* Terminate with "failure" status */
   exit(EXIT_FAILURE);

}  /* End of mHtiGbfExit() */


/*******************************************************************************
** End of File Name: HtiGenBinary.c
*******************************************************************************/
